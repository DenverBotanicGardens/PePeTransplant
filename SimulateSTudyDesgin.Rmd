---
title: "Penstemon penlandii transplant study"
author: "Michelle DePrenger-Levin"
date: "2023-02-06"
output:
  word_document: default
  html_document: default
  pdf_document: default
---
```{r}

rm(list=ls()) 
library(R2jags)
library(runjags)
library(mcmcplots)
library(boot)
library(dplyr)
library(tidyr)
library(ggplot2)
```



Want to know spring or fall (make a dag)

1. Poisson for reproduction output
2.Simulate beta distribution for survival of stages [0,1]
3. binomial for being reproductive or not
both have parameters: 
normal for Beta_transplanttime impact of spring vs. fall
lognormal for Beta_size impact of size  

Put together for MPM and estimate the lambda (or an IPM) 

$\epsilon$ 
$\phi$ survival probability, among-individual variation
$\psi$ trident breeding success probability, among-individual variation

################################################################################################################################################################################################################  
  simple model of survival (grouping by treatment and control)
  Penstemon penlandii model and data to test
  
```{r,"PePeTC"}
modelpepeSimulation <- '	
data {
  for(i in 1:N) {
    # Likelihood
    # Initial state
    y_surv[i,1] ~ dbern(1) ## The first year all are alive to transplant or tag
    y_rep[i,1] ~ dbern(p_rep[i,1] * y_surv[i,1])  ## reproduction depends on survival 
    logit(p_rep[i,1]) <- alpha[ ct[i] ] + bsize * size[i] + alpha1[i, 2] + epsilon[1,2]
    
    # Three years of monitoring
    for(t in 2:nYears){
      y_surv[i,t] ~ dbern(p_surv[i,t])
      logit(p_surv[i,t]) <- alpha[ct[i]] + bsize * size[i] + gamma[1] * y_rep[i, t-1] + 
                            alpha1[i,1,ct[i]] + epsilon[t,1,ct[i]] 
      
      y_rep[i,t] ~ dbern(p_rep[i,t] * y_surv[i,t]) ## reproduction dependent on survival
      logit(p_rep[i,t]) <- alpha[ ct[i] ] + bsize * size[i] + gamma[2] * y_rep[i, t-1] +
                         alpha1[i,2] + epsilon[t,2,ct[i]]
    } ## Year loop
  } ## Individuals loop
}

  model{
  fake <- 0
  }
  '



# parameters for simulations 
N <- 400 # nb of observations, but would need to be larger with some that are zero in the first or first and second year to account for recruitment
nPlots <- 4
ct <- as.factor(rep(c("trSp","trFa","coSo","coDe"), each = 100)) # predictor, 4,3,2,1
nYears <- 4
as <- c(1.1,1,-1,-2) ## because centered, looking for difference from mean
alpha <- as - mean(as) # index:  coDe = 1, coSo =2,  trFa =3, trSp=4
ar <- c(1.1,1.2,-2,-2.1)
alpha.r <- ar - mean(ar)
boot::inv.logit(as) ## 0.7502601 0.7310586 0.2689414 0.1192029 are the probabilities
boot::inv.logit(alpha) 

bsize <- 0.1 ## increasing survival with size
# alphas <- inv.logit(rep(as, each = 100))
size <- runif(N, 1, 15) ## plants will be at least 1cm once germinated and up to about 15cm at largest

mu.surv <- inv.logit(alpha)
mu.rep <- inv.logit(alpha.r)

sigma.alpha.surv <- 0.2 # Among-individual variation in survival
sigma.alpha.rep <- 0.2 # Among-individual variation in reproductive success
cor.alpha <- 0.6 # Correlation between survival and reproduction individual variation

sigma.eps.surv <- 0.5 # Survival temporal variation
sigma.eps.rep <- 0.5 # Breeding success temporal variation
cor.eps <- 0 # Correlation between survival and breeding temporal variation

## Conditional on survival (from year t-1), an individual might be reproductive in year t 
## Fay et al 2021, temporal variation, state-dependent variation, probablity that event for individual i at time t depends on state of that individual at time t-1
gamma.surv <- - logit(0.4) # State effect for survival
gamma.rep <- logit(0.7)-logit(0.6) # State effect for reproductive success

# Variance covariance matrix, separate for each plot, but shouldn't change among control/treatment 
# varcov.alpha <- array(NA, dim = c(2,2,nPlots))
# varcov.alpha[1,1,] <- sigma.alpha.surv^2
# varcov.alpha[2,2,] <- sigma.alpha.rep^2
# varcov.alpha[1,2,] <- varcov.alpha[2,1,] <- cor.alpha * sigma.alpha.surv * sigma.alpha.rep
# alpha1 <- rmvnorm(N, c(0,0), varcov.alpha)
varcov.alpha <- array(NA, dim = c(2,2))
varcov.alpha[1,1] <- sigma.alpha.surv^2
varcov.alpha[2,2] <- sigma.alpha.rep^2
varcov.alpha[1,2] <- varcov.alpha[2,1] <- cor.alpha * sigma.alpha.surv * sigma.alpha.rep
alpha1 <- rmvnorm(N, c(0,0), varcov.alpha)

## Simulation of temporal variation
epsilon <- array(NA, dim = c(nYears,2,nPlots))
# Variance covariance matrix
varcov.eps <- array(NA, dim = c(2,2,nPlots))
varcov.eps[1,1,] <- sigma.eps.surv^2
varcov.eps[2,2,] <- sigma.eps.rep^2
varcov.eps[1,2,] <- varcov.eps[2,1,] <- cor.eps * sigma.eps.surv * sigma.eps.rep
epsilon <- rmvnorm(nYears, c(0,0), varcov.eps)

# Reproductive process success (1), failed (2)  ; rows: 400 individuals, col: 3 years, z: 4 plots
rep.prob <- array(NA, dim = c(N, nYears, nPlots))
for(t in 1:nYears){
  for(p in 1:nPlots){
    for(i in 1:N){
      rep.prob[i,t,p] <- logit(mu.rep[p]) + alpha1[i,2] + epsilon[t,2]  ## 1 is survival, 2 is reproduction
    }
  }
}

## Simulation of the survival process
mat.s <- array(NA, dim = c(N, nYears, nPlots)) # Survival matrix
# Year and individual specific survival probabilities
s.prob <- array(NA, dim = c(N, nYears, nPlots))
for (t in 1:nYears){
  for (p in 1:nPlots){
    for (i in 1:N){
      s.prob[i,t,p] <- logit(mu.rep[p]) + alpha1[i,1] + epsilon[t,1]
    }
  }
}

prec_gamma <- (log(2)/2)^-2
gamma <- c()
for (j in 1:2) {
  gamma[j] <- dnorm(0.0, prec_gamma)
}

# parameters are treated as data for the simulation step
data<-list(N=N,ct=ct, nYears = nYears, alpha1= alpha1, alpha = alpha, bsize = bsize, size = size, #s.prob=s.prob,
           # rep.prob = rep.prob, 
           epsilon = epsilon, # gamma.rep = gamma.rep, gamma.surv = gamma.surv,
           gamma = gamma)

# Run JAGS but monitor the response variable instead of the parameters because we're checking if the model works 
out <- run.jags(modelpepeSimulation, data = data,monitor=c("y_surv","y_rep"),sample=2, n.chains=1, summarise=FALSE)

Simulated <- coda::as.mcmc(out)
# dataSim <- Simulated %>%
#   mutate(y_surv1 = )
y_surv1 <- Simulated[1,1:400]
y_surv2 <- Simulated[2,1:400]
y_rep1 <- Simulated[1,401:800]
y_rep2 <- Simulated[2,401:800]
## spit out y for each data point
dat <- as.vector(Simulated)

data.frame(y_surv1, y_surv2, y_rep1, y_rep2, size, ct) %>%
  ggplot(   aes(size, y_surv1, color = ct))+
    geom_smooth(method = "glm", method.args = list(family = "binomial"),se = TRUE, alpha = 0.5)+
    theme_bw()
    

```

 <https://mmeredith.net/blog/2017/Categories_in_JAGS.htm>     
# fit model center caegorical coefficients (subtract out the mean)
```{r}
# specify model in BUGS language
modelpepe <- 	
paste("	
model {
  for(i in 1:N) {
    y[i] ~ dbern(p[i])
    logit(p[i]) <- alpha[ ct[i] ]  ## one for each plot
  }

  # Priors
    for(i in 1:4) {
      Plottemp[i] ~ dunif(-5,5)   ## find the mean across plotTypes
    }
  alpha <- Plottemp - mean(Plottemp) ## resulting in change in centered Plot for each type
}")
writeLines(modelpepe,"centered_pepe.jags")

# data, dat from simulation
jags.data <- list(y = dat, ct = ct, N = length(dat))

# initial values
inits <- function(){list(alpha = rnorm(1))}  

# parameters monitored
parameters <- c("alpha")

# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 2

# call JAGS from R
res <- jags(jags.data, inits = NULL, parameters, 
            "centered_pepe.jags", n.chains = nc, n.thin = nt, 
            n.iter = ni, n.burnin = nb,
            working.directory = getwd()) 

print(res, digits = 3)

## Check convergence 
# trace plots
traplot(res,c("alpha", "bPlot"))
# posterior distributions
denplot(res,c("alpha", "bPlot"))
```

#######################################################################################################



############################# Centered categorical, size ##############################################


    ## b0=alpha, bPlayer=bPlot, player=ct, bFluff=bSize, fluff=size
# fit model center caegorical coefficients (subtract out the mean)
```{r}  
modelpepeSize <- 	'
data {
  for(i in 1:N) {
    y[i] ~ dbern(p[i])
    logit(p[i]) <- bPlot[ct[i]] + bSize * size[i]
  }
}

  model{
  fake <- 0
  }
  '

# parameters for simulations 
N = 400 # nb of observations
TC = 4
ct <- as.numeric(as.factor(rep(c("trSp","trFa","coSo","coDe"), each = 100))) # predictor, 4,3,2,1
bPlot <- c(1.1,1,-1,-2) # index:  coDe = 1, coSo =2,  trFa =3, trSp=4
bSize <- 1
size <- rlnorm(N, log(5), 1)
# parameters are treated as data for the simulation step
data<-list(N=N,ct=ct, bPlot=bPlot, bSize = bSize, size = size)
# Run JAGS but monitor the response variable instead of the parameters because we're checking if the model works 
out <- run.jags(modelpepeSize, data = data,monitor=c("y"),sample=1, n.chains=1, summarise=FALSE)
Simulated <- coda::as.mcmc(out)
## spit out y for each data point
dat <- as.vector(Simulated)

# specify model in BUGS language
modelpepeSize <- 	
paste("	
model {
  for(i in 1:N) {
    y[i] ~ dbern(p[i])
    logit(p[i]) <- bPlot[ct[i]] + bSize * size[i]
    }

  # Priors
  alpha ~ dunif(-5,5) ## because it is centered 
    for(i in 1:4) {
      Plottemp[i] ~ dnorm(0, 0.01)   ## find the mean across plotTypes
    }
  bPlot <- Plottemp - mean(Plottemp) ## resulting in change in centered Plot for each type
  bSize ~ dunif(-5,5)
}")
writeLines(modelpepeSize,"centered_pepeSize.jags")

# data, dat from simulation
jags.data <- list(y = dat, ct = ct, N = length(dat), size = size)

# initial values
# inits <- function(){list(alpha = rbeta(1,1,1), beta = rnorm(1))}  

# parameters monitored
parameters <- c("bPlot", "bSize")

# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 2

# call JAGS from R
res <- jags(jags.data, inits = NULL, parameters, 
            "centered_pepeSize.jags", n.chains = nc, n.thin = nt, 
            n.iter = ni, n.burnin = nb,
            working.directory = getwd()) 

print(res, digits = 3)

## Check convergence 
# trace plots
traplot(res,c( "bPlot","bSize"))
# posterior distributions
denplot(res,c( "bPlot","bSize"))
```

#######################################################################################################


############################# Centered categorical, size, centered stage ##############################################


    ## b0=alpha, bPlayer=bPlot, player=ct, bFluff=bSize, fluff=size
# fit model center caegorical coefficients (subtract out the mean)
```{r}  
# parameters for simulations 
N = 400 # nb of observations
TC = 4
ct <- as.factor(rep(c("trSp","trFa","coSo","coDe"), each = 100)) # predictor, 4,3,2,1
alpha <- mean(c(1.1,1,-1,-2)) ## because centered, looking for difference from mean
bPlot <- c(1.1,1,-1,-2) # index:  coDe = 1, coSo =2,  trFa =3, trSp=4
bSize <- 1
size <- rlnorm(N, log(5), 1)
bStage <- 1.1 ## slightly more likely to survive as a reproductive than juvenile (long-lived perennial) ???
## prob of rep depends on size, 0=veg, 1=rep
alphaVegRep <- 0
bVegRep <- 0.1 # slightly more likely to reproductive as get bigger
stage <- unlist(lapply(inv.logit(alphaVegRep + bVegRep*size), function(x) rbinom(n=1, size=1, prob=x)))  
# parameters are treated as data for the simulation step
dat <- unlist(lapply(inv.logit(alpha + bPlot[ct] + size*bSize + stage*bStage), function(x) rbinom(n = 1, size = 1, prob = x)))

data.frame(ct, size, stage)

# specify model in BUGS language
modelpepeSize <- 	
paste("	
model {
  # Likelihood
    for(i in 1:N) {
      y[i] ~ dbern(p[i])
      logit(p[i]) <- alpha + bPlot[ct[i]] + bSize * size[i] + bStage * stage[i]
      
      stage[i] ~ dbern(pS[i])
      logit(pS[i]) <- alphaVegRep + bVegRep * size[i]
    }
    
    # Stage, Hierarchical based on size, survival based on stage and size (or maybe confounded)
    # for(i in 1:N)
    # }

  # Priors
  alpha ~ dunif(-5,5) ## because it is centered 
    for(i in 1:4) {
      Plottemp[i] ~ dnorm(0, 0.01)   ## find the mean across plotTypes
    }
  bPlot <- Plottemp - mean(Plottemp) ## resulting in change in centered Plot for each type
  bSize ~ dunif(-5,5)
  bStage ~ dunif(-5,5)
  alphaVegRep ~ dbern(0.5)
  bVegRep ~ dunif(-5,5)
  
}")
writeLines(modelpepeSize,"centered_pepeSize.jags")

# data, dat from simulation
jags.data <- list(y = dat, ct = ct, N = length(dat), size = size)

# initial values
# inits <- function(){list(alpha = rbeta(1,1,1), beta = rnorm(1))}  

# parameters monitored
parameters <- c("bPlot", "alpha", "bSize", "bStage", "alphaVegRep","bVegRep")

# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 2

# call JAGS from R
res <- jags(jags.data, inits = NULL, parameters, 
            "centered_pepeSize.jags", n.chains = nc, n.thin = nt, 
            n.iter = ni, n.burnin = nb,
            working.directory = getwd()) 

print(res, digits = 3)

## Check convergence 
# trace plots
traplot(res,c("alpha", "bPlot","bSize", "bStage", "alphaVegRep","bVegRep"))
# posterior distributions
denplot(res,c("alpha", "bPlot","bSize", "bStage", "alphaVegRep","bVegRep"))
```

#######################################################################################################


############################# Centered categorical, size, centered stage ##############################################


    ## b0=alpha, bPlayer=bPlot, player=ct, bFluff=bSize, fluff=size
# fit model center caegorical coefficients (subtract out the mean)
```{r}  
# parameters for simulations 
N = 400 # nb of observations
TC = 4
ct <- as.factor(rep(c("trSp","trFa","coSo","coDe"), each = 100)) # predictor, 4,3,2,1
alpha <- mean(c(1.1,1,-1,-2)) ## because centered, looking for difference from mean
bPlot <- c(1.1,1,-1,-2) # index:  coDe = 1, coSo =2,  trFa =3, trSp=4
bSize <- 1
size <- rlnorm(N, log(5), 1)
bStage <- 1.1 ## slightly more likely to survive as a reproductive than juvenile (long-lived perennial) ???
## prob of rep depends on size, 0=veg, 1=rep
alphaVegRep <- 0
bVegRep <- 0.1 # slightly more likely to reproductive as get bigger
stage <- unlist(lapply(inv.logit(alphaVegRep + bVegRep*size), function(x) rbinom(n=1, size=1, prob=x)))  
# parameters are treated as data for the simulation step
dat <- unlist(lapply(inv.logit(alpha + bPlot[ct] + size*bSize + stage*bStage), function(x) rbinom(n = 1, size = 1, prob = x)))

data.frame(ct, size, stage)

# specify model in BUGS language
modelpepeSize <- 	
paste("	
model {
  # Likelihood
    for(i in 1:N) {
      y[i] ~ dbern(p[i])
      logit(p[i]) <- alpha + bPlot[ct[i]] + bSize * size[i] + bStage * stage[i]
    }
    
    # Stage, Hierarchical based on size, survival based on stage and size (or maybe confounded)
    # for(i in 1:N)
    # }

  # Priors
  alpha ~ dunif(-5,5) ## because it is centered 
    for(i in 1:4) {
      Plottemp[i] ~ dnorm(0, 0.01)   ## find the mean across plotTypes
    }
  bPlot <- Plottemp - mean(Plottemp) ## resulting in change in centered Plot for each type
  bSize ~ dunif(-5,5)
  bStage ~ dunif(-5,5)
  
}")
writeLines(modelpepeSize,"centered_pepeSize.jags")

# data, dat from simulation
jags.data <- list(y = dat, ct = ct, N = length(dat), size = size, stage = stage)

# initial values
# inits <- function(){list(alpha = rbeta(1,1,1), beta = rnorm(1))}  

# parameters monitored
parameters <- c("bPlot", "alpha", "bSize", "bStage", "alphaVegRep","bVegRep")

# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 2

# call JAGS from R
res <- jags(jags.data, inits = NULL, parameters, 
            "centered_pepeSize.jags", n.chains = nc, n.thin = nt, 
            n.iter = ni, n.burnin = nb,
            working.directory = getwd()) 

print(res, digits = 3)

## Check convergence 
# trace plots
traplot(res,c("alpha", "bPlot","bSize", "bStage", "alphaVegRep","bVegRep"))
# posterior distributions
denplot(res,c("alpha", "bPlot","bSize", "bStage", "alphaVegRep","bVegRep"))
```

#######################################################################################################

Old try, trying again  
################################################################################################################################################################################################################  
  simple model of survival (grouping by treatment and control)
  Penstemon penlandii model and data to test
  
```{r,"Old wrong"}
modelpepe <- '	
data {
  for(i in 1:N) {
    y[i] ~ dbern(p[i])
    logit(p[i]) <- alpha + bPlot[ct[i]] ## one for each plot
  }
}

  model{
  fake <- 0
  }
  '


# parameters for simulations 
N = 400 # nb of observations
TC = 4
ct <- as.factor(rep(c("trSp","trFa","coSo","coDe"), each = 100)) # predictor, 4,3,2,1
alpha <- mean(c(1.1,1,-1,-2)) ## because centered, looking for difference from mean
bPlot <- c(1.1,1,-1,-2) # index:  coDe = 1, coSo =2,  trFa =3, trSp=4
# parameters are treated as data for the simulation step
# dat <- unlist(lapply(inv.logit(alpha + bPlot[ct]), function(x) rbinom(n = 1, size = 1, prob = x)))

## Or simulated with model
data<-list(N=N,ct=ct, alpha=alpha,bPlot=bPlot)

# Run JAGS but monitor the response variable instead of the parameters because we're checking if the model works 
out <- run.jags(modelpepe, data = data,monitor=c("y"),sample=1, n.chains=1, summarise=FALSE)

Simulated <- coda::as.mcmc(out)
## spit out y for each data point
dat <- as.vector(Simulated)

```

 <https://mmeredith.net/blog/2017/Categories_in_JAGS.htm>     
# fit model center caegorical coefficients (subtract out the mean)
```{r}
# specify model in BUGS language
modelpepe <- 	
paste("	
model {
  for(i in 1:N) {
    y[i] ~ dbern(p[i])
    logit(p[i]) <- alpha + bPlot[ct[i]]
    }

  # Priors
  alpha ~ dunif(-5,5) ## because it is centered 
    for(i in 1:4) {
      Plottemp[i] ~ dnorm(0, 0.1)   ## find the mean across plotTypes
    }
  bPlot <- Plottemp - mean(Plottemp) ## resulting in change in centered Plot for each type
}")
writeLines(modelpepe,"centered_pepe.jags")

# data, dat from simulation
jags.data <- list(y = dat, ct = ct, N = length(dat))

# initial values
inits <- function(){list(alpha = rbeta(1,1,1), beta = rnorm(1))}  

# parameters monitored
parameters <- c("bPlot", "alpha")

# MCMC settings
ni <- 10000
nt <- 6
nb <- 5000
nc <- 2

# call JAGS from R
res <- jags(jags.data, inits = NULL, parameters, 
            "centered_pepe.jags", n.chains = nc, n.thin = nt, 
            n.iter = ni, n.burnin = nb,
            working.directory = getwd()) 

print(res, digits = 3)

## Check convergence 
# trace plots
traplot(res,c("alpha", "bPlot"))
# posterior distributions
denplot(res,c("alpha", "bPlot"))
```

#######################################################################################################
