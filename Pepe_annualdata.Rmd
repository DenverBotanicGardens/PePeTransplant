---
title: "Pepe Annual Data Analysis"
author: "Michelle DePrenger-Levin"
date: "2024-06-26"
output: R script
---


2024    
```{r}

rm(list=ls())
library(R2jags)
library(runjags)
library(mcmcplots)
library(boot)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(RMark)

library(myClim)

```


Import data     

Move to GitHub once checked and correct  
```{r}

trans2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_transects.csv", header = FALSE)

names(trans2024) <- c("TransectID","transectID","Block","ControlORTreatment","OriginTag","EndTag","Comments")

## Once this gets corrected, for now use old
# plants2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_plants.csv")

plants2024 <- read.csv( "C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/Penstemon-penlandii_tags_seasonslot.csv")
names(plants2024) <- c("Remove","transectID", "Block", "Season", 
                       "Transect_position", "x", "y","plantID")

plants2024 <- plants2024[,-1]

data2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_data.csv")


### Don't need this once Rick updates in database and pulls data out
## PlantID 118 is for Transect 8 slot 8 spring transplant but I put down Y = 4.75 which is incorrect. Should be slot 8, 0.75, 3.75
surv2023_2024 <- data2024 %>%
  left_join(plants2024, by = "plantID")

surv2023_2024 %>%
  filter(transectID == 8 & !is.na(Transect_position))

## Just assign PlantID to next one for all the transect 8, slot 10 ones that are also 118
nextPID <- (max(surv2023_2024$plantID) + 1)
surv2023_2024$plantID[ (surv2023_2024$transectID == 8 & surv2023_2024$Transect_position == 10 &
                          !is.na(surv2023_2024$Transect_position))] <- nextPID


surv2023_2024 %>%
  filter(plantID == 118)
```


# Check correct assigment of PlantIDs to transplants (and subsequently all of them)   
```{r}

table(surv2023_2024$date, surv2023_2024$Season)

surv2023_2024 %>%
  filter(Season == "Fall" & date == "2023-05-31")

## Transect_position 10 is fall in Transect 8 but isn't offset. 
## In Transect 8, slot 2 is offset -> center and is a spring transplant. However, these measurements are with slot 8 but I on paper put down 4.75 incorrectly. So this line should be Transect_position 8

surv2023_2024$Transect_position[surv2023_2024$date == "2023-05-31" & surv2023_2024$Season == "Fall"] <- 8
surv2023_2024$comments[surv2023_2024$date == "2023-05-31" & surv2023_2024$Season == "Fall"] <- "offset hole 5cm -> origin"
surv2023_2024$y[surv2023_2024$date == "2023-05-31" & surv2023_2024$Season == "Fall"] <- 3.75
surv2023_2024$Season[surv2023_2024$date == "2023-05-31" & surv2023_2024$Season == "Fall"] <- "Spring"
## Now looks good
table(surv2023_2024$date, surv2023_2024$Season)

```



# Survival   
```{r}

table(surv2023_2024$Season, surv2023_2024$date)

# combine the 2024 dates, shouldn't be different by date, should be different by recorded by
surv_wide <- surv2023_2024 %>%
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  pivot_wider(names_from = c(Date, recordedBy),
              values_from = heightInCentimeters,
              id_cols = c(plantID,Season,transectID, Block) 
               ,values_fn = first  ## Because why? why are there double for the same date and observers?
              ) %>%
  arrange(transectID,Block,Season)

surv_wide %>%
  filter(Season %in% c("Spring","Fall")) 

## After a few more years of data, might be useful. Not sure why the line for first set of Spring isn't at 1
surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>% 
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>% 
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>%
  ggplot(  aes(Date, surv, color = Season)) +
    geom_point(pch = "|")+
    geom_smooth(method = "glm", 
                method.args = list(family = "binomial"), 
                se = TRUE) +
    scale_color_manual(values = c("darkgreen","violet"))


## Percent survival at each date
surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>% 
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>% 
  group_by(Season, Date, transectID, recordedBy) %>%
  summarise(PercSurv = sum(surv)/5) %>%
  ggplot(  aes(Date, PercSurv, color = Season)) +
    geom_point(pch = 5)+
    scale_color_manual(values = c("darkgreen","violet")) +
    theme_bw()


surv2023_2024 <- surv2023_2024 %>% 
  filter(!(date == "2023-05-31" & y == 4.75))

surv2023_2024 <- surv2023_2024 %>%
  distinct(Season,date,plantID,transectID,Transect_position,x,y,  .keep_all = TRUE)
  
## Where are there double records? the 118 and the other duplicated one? spring?  
## PlantID 982 is for two different plants, both in there twice
# Plant 118 is in twice as slot 8 with 3.75 and 4.75 Spring, same measurements. 
## Plant 982 has 0.75 and 1.75 for both slot 3 and 4, need new plantID for one of them - Rick is doing
# Transect 34, slots 2, 5, and 8 repeated. 8 has two different measurements - because Adriana and Michelle did a second recording of them! Adding the other two with a different recorder. Rick is doing


# Fix above and rerun
surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>% 
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>% 
  group_by(Season, Date, transectID, recordedBy) %>%
  mutate(PercSurv = sum(surv)/5) %>%
  filter(PercSurv > 1) %>%
  select(c(plantID, date, heightInCentimeters, recordedBy, transectID,Transect_position, x,y,PercSurv)) %>%
  arrange(Season,Transect_position) %>%
  print(n=30)

################################## Should all be fixed in database and come out clean ###############################

surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>%  
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>%
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  filter(date == "2024-06-24") %>%
  ggplot(  aes(transectID, surv, color = Season)) +
    geom_point(pch = "|")+
    geom_smooth(method = "glm", 
                method.args = list(family = "binomial"), 
                se = TRUE) +
    scale_color_manual(values = c("darkgreen","violet")) +
    theme_bw()

surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>% 
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>% 
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>%
  filter(!(Season == "Fall" & Date == "2023-05-31")) %>%
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  filter(date == "2024-06-24") %>%
  ggplot(  aes(transectID, surv)) +
    geom_point(pch = "|")+
    geom_smooth(method = "glm", 
                method.args = list(family = "binomial"), 
                se = TRUE) +
    theme_bw()

## Survival depend on size or reproduction?

surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>%  
  mutate(InitialHeight = case_when(Season=="Spring" & date ==  "2023-05-31" ~ heightInCentimeters,
                                   Season=="Fall" & date == "2023-10-16" ~ heightInCentimeters)) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>%
  filter(!(Season == "Fall" & date == "2023-05-31")) %>%
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  filter(date == "2024-06-24") %>%
  ggplot(  aes(InitialHeight, surv)) +
    geom_point(pch = "|")+
    geom_smooth(method = "glm", 
                method.args = list(family = "binomial"), 
                se = TRUE) +
    theme_bw()

## Need initial height
surv_wide_perfectdetection <- surv2023_2024 %>%
  mutate(date = case_when(date == "2024-06-25" ~ "2024-06-24",
                          TRUE ~ date)) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(date2 = gsub("[[:punct:]]", "", surv2023_2024$date))  %>%
  pivot_wider(names_from = c(date2),
              values_from = heightInCentimeters,
              id_cols = c(plantID,Season,transectID, Block),
              names_prefix = "Date",
               ,values_fn = function(x) max(x,na.rm = TRUE)  ## Because why? why are there double for the same date and observers?
              ) %>%
  arrange(transectID,Block,Season) %>%
  mutate(InitialHeight = case_when(Season == "Spring" ~ Date20230531,
                                   Season == "Fall" ~ Date20231016))

## What?!?! Now there are more measurements for fall in the spring! that's wrong!!! 
surv_wide_perfectdetection %>%
  filter(Season %in% c("Spring","Fall")) %>%
  filter(Season == "Fall" & !is.na(Date20230531))

surv_wide_perfectdetection %>%
  filter(Season %in% c("Fall","Spring")) %>%
  mutate(surv = case_when('2024-06-24' > 0 ~ 1,
                          '2024-06-24' == 0 ~ 0)) %>%
  group_by(transectID, Block, Season) %>%
  summarise(percSurv = sum(surv)/5)
  ggplot(  aes(Season, surv))

```



## Survival by transplant time  
```{r}

surv_transplants <- surv2023_2024 %>%
  filter(Season %in% c("Spring", "Fall")) %>%  
  mutate(InitialHeight = case_when(Season=="Spring" ~ heightInCentimeters[date == "2023-05-31"],
                                   Season=="Fall" ~ heightInCentimeters[date == "2023-10-16"])) %>%
  mutate(Date = as.Date(date)) %>%
  arrange(Date) %>%
  mutate(surv = case_when(heightInCentimeters > 0 ~ 1,
                          heightInCentimeters == 0 ~ 0)) %>%
  filter()


glm.season <- glm()



glm.list <- list(brnull,br1a,br2,br3,br1b,br1,br2a, br3a)
glm.names <- as.character(unlist(lapply(glm.list,formula)))
(glm.results <- aictab(glm.list, modnames=glm.names))

```


### Run with rmark  
```{r}

```





### Examples for true models

Gimenez 2020 <https://www.youtube.com/watch?v=VR8qdNvCaGk>     
phi(.), p(.)   
```{r}

# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi * z[i,t-1]) # will be alive on first encounter, then Bernoulli
    
    # Obervation process
    y[i,t] ~ dbern(p * z[i,t]) # true state times prob of detection
    
    } # t time
  
} # loop over all i individuals

phi ~ dunif(0,1) # prior for survival
p ~ dunif(0,1) # Prior for recapture




```

CJS phi(t), p(t)   
```{r}

# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi[t-1] * z[i,t-1]) # will be alive on first encounter, then Bernoulli, survival for each time interval
    
    # Obervation process
    y[i,t] ~ dbern(p[t-1] * z[i,t]) # true state times prob of detection, detection for each time interval
    
    } # t time
  
} # loop over all i individuals

## Need prior for each occasion
for(t in 1:n.occasions-1){
  phi[t] ~ dunif(0,1) # prior for survival
  p[t] ~ dunif(0,1) # Prior for recapture
}




```


Differences among groups, individual covariates     
```{r}


# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi[i,t-1] * z[i,t-1]) # will be alive on first encounter, then Bernoulli, survival for each time interval
    
    # Obervation process
    y[i,t] ~ dbern(p[i,t-1] * z[i,t]) # true state times prob of detection, detection for each time interval
    
    } # t time
  
} # loop over all i individuals

## Need prior for each occasion
for(i in 1:nind){
  for(t in 1:(n.occasions-1)){  # in interval from t to t+1
    phi[i,t] ~ dunif(0,1) # prior for survival
    p[i,t] ~ dunif(0,1) # Prior for recapture
  }
}

```

Apply constraints on parameters, phi(.), p(.)   
```{r}

# Priors and constraints 
for(i in 1:nind){
  for(t in 1:(n.occasions-1)){
    phi[i,t] <- mean.phi   # not a 'mean' but a constant
    p[i,t] <- mean.p       # not a 'mean' but a constant
  }
}  

# Prior  
mean.phi ~ dunif(0,1)
mean.p ~ dunif(0,1)


```



Simulate capture-history matrix   
```{r}
n.occasions <- 6
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)

# Define matrices with survival and recapture probs
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
P <- matrix(p, ncol = n.occasions-1, nrow=sum(marked))

simul.cjs <- function(PHI, P, marked){
  n.occasions <- dim(PHI)[2] + 1
  CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
  
  # Define a vector with the occasion of marking
  mark.occ <- rep(1:length(marked), marked[1:length(marked)])
  # Fill the CH matrix 
  for(i in 1:sum(marked)){
    CH[i, mark.occ[i]] <- 1     # First is a 1
    if(mark.occ[i] == n.occasions) next
      for(t in (mark.occ[i]+1):n.occasions){
        # Bernoulli trial for survival
        sur <- rbinom(1,1,PHI[i,t-1])
        if(sur==0) break   # If dead, move to next individual
        # Bernoulli for recapture
        rp <- rbinom(1,1,P[i,t-1])
        if(rp==1) CH[i,t] <- 1  # If you recaptured, it gets a '1'
      } # t
  } # i
return(CH)
  }

## Simulate!
sim1 <- simul.cjs(PHI, P, marked)

# Create vector with occasion of marking  
get.first <- function(x) min(which(x != 0))
f <- apply(sim1, 1, get.first)  ## Apply across rows


## BUGS  
SimulCJS <- 
  paste("
model {
  
  # Constraints
  for(i in 1:nind){
    for(t in 1:(n.occasions-1)){
      phi[i,t] <- mean.phi
      p[i,t] <- mean.p
    }
  }
  
  # Priors
  mean.phi ~ dunif(0,1)
  mean.p ~ dunif(0,1)
  
  # Likelihood
  for(i in 1:nind){
  
    # Define latent state at first capture
    z[i,f[i]] <- 1
    for(t in (f[i]+1):n.occasions){
    
      # State process
      z[i,t] ~ dbern(phi[i,t-1] * z[i, t-1])
      
      # Observation process
      y[i,t] ~ dbern(p[i,t-1] * z[i,t])
    }
  }
}

")

writeLines(SimulCJS, "SimulCJS.jags")

jags.data <- list(y = sim1,
                  f= f,
                  nind = nrow(sim1),
                  n.occasions = ncol(sim1))

# Set 'good' initial values
z.inits <- function(ch){
  state <- ch
  state[state==0] <- 1
  get.first <- function(x){ min(which(x != 0)) }
  f <- apply(ch, 1, get.first)
    for(i in 1:nrow(ch)){
      state[i, 1:f[i]] <- NA
    }
  return(state)
}

inits <- function(){list(mean.phi = runif(1,0,1),
                         mean.p = runif(1,0,1),
                         z = z.inits(sim1))}   # The latent states (alive, dead) also need initial values
  # Could monitor the latent states (if we have missing data)

parameters <- c("mean.phi","mean.p")

# MCMC settings
ni <- 1000
nt <- 1
nb <- 500
nc <- 3

cjs.c.c <- jags(data = jags.data,
                inits = inits,
                parameters.to.save = parameters,
                model.file = "SimulCJS.jags",
                n.chains = nc,
                n.thin = nt,
                n.iter = ni, n.burnin = nb,
                working.directory = getwd())

print(cjs.c.c, digits = 3)

## This is around 50 minutes

# save(cjs.c.c, file = )
```



Second part <https://www.youtube.com/watch?v=vYWj50Sj-q4>  
Random time effects
```{r}

n.occasions >- 12
marked <- rep(50, n.occasions-1)  ## Annual number of newly marked individuals
mean.phi <- 0.65
sigma2.phi <- 1
p <- rep(0.4, n.occasions-1)

## Annual survival probabilities on logistic scale
logit.phi <- rnorm(n.occasions-1, qlogis(mean.phi), sigma2.phi^0.5)
logit.phi
phi <- plogis(logit.phi)
phi
```


https://www.youtube.com/watch?v=vYWj50Sj-q4 
stopped at Minute 29



Tomst data logger  
Put in issue on GitHub
```{r}

# install.packages("myClim")


tms.f <- mc_read_files(c("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_lolly_TOMSTdatalogger/data_95135950_2024_06_24_0.csv",
                         "C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_lolly_TOMSTdatalogger/data_95135951_2024_06_24_0.csv",
                         "C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_lolly_TOMSTdatalogger/data_95135952_2024_06_24_0.csv"),
                       dataformat_name = "TOMST", silent = TRUE)


tms.fs <- mc_read_files(paths = "C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_lolly_TOMSTdatalogger",
                        dataformat_name = "TOMST")

```

