---
title: "Pepe Annual Data Analysis"
author: "Michelle DePrenger-Levin"
date: "2024-06-26"
output: R script
---


2024    
```{r}

rm(list=ls())
library(R2jags)
library(runjags)
library(mcmcplots)
library(boot)
library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)
library(RMark)

```


Import data     

Move to GitHub once checked and correct  
```{r}

trans2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_transects.csv", header = FALSE)

names(trans2024) <- c("TransectID","transectID","Block","ControlORTreatment","OriginTag","EndTag","Comments")

## Once this gets corrected, for now use old
# plants2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_plants.csv")

plants2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/Penstemon-penlandii_tags_MySQL_season&position.csv")
names(plants2024) <- c("id", "transectID", "Block", "Season", "Transect_position", "X", "Y", "plantID")

data2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/20240708_dbExport/20240708_dbExport_pepe_triState_data.csv")

# transplants2024 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/Data/Penstemon-penlandii_tags_existtransplant_MySQL.csv")


## These are both at time of transplant and fall (if spring transplant)
transplant2merge <- transplants2024 %>%
  filter((Season == "Fall" & Date == "20231016" ) | (Season == "Spring" & Date == "20230531")) %>%
  select(c(TransectID:Transect_position , Date:Y))

## There are 200 transplants
transplant2merge %>%
  filter(!is.na(Transect_position))

table(transplant2merge$TransectID)


transplant2merge %>%
  filter(!is.na(Transect_position) & 
           !(X %in% c(0.25,0.75)))

## This is the mistake from transect 10
plants2024 %>%
  filter(x == 1.25)

plants2024 %>%
  filter(x > 1)

transplant2merge$X[transplant2merge$X > 1] <- 0.25

## Missing 9 plants?!?!
trans2023 <- plants2024 %>%
  right_join(transplant2merge, by = c("transectID" = "TransectID", "x"= "X", "y" = "Y"), keep = TRUE)

## Missing one in each of 8, (10,) 12, 14,18,32,36,38 and an extra from 36. Probably the ones that aren't right on the 025 or 0.75
table(trans2023$transectID)
table(trans2023$transectID, trans2023$Season)


## Transplants in spring
spring2023 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/2023_Penstemon-penlandii_Annualreport/20230626Spring_Penstemon-penlandii.csv")

## There are 9 without normal X and Y, one error (3.75 for both X and Y in transect 10)
head(spring2023)
# Missing one in 10, 32, 36; X and Y off in 10, 20, 22, 24, 28, 36, 40 
spring2023 %>%
  filter(!is.na(Transect_position) &  !(X %in% c(0.25,0.75)))

fall2023 <- read.csv("C:/Users/deprengm/Denver Botanic Gardens/Conservation - General/AllProjectsBySpecies/Penstemon-penlandii/Penstemon-penlandii_Projects/Tri-State_Transplant_2023-2026/2023_Penstemon-penlandii_Annualreport/20231016Fall_Penstemon-penlandii_dataentry_2.csv")

## Two in fall that aren't right at the spot, but those are both in the xy and the X, Y. in 12 and 18
## Missing one in fall for 12, 14, 18, and 36
head(fall2023)
fall2023 %>%
  filter(!is.na(Transectposition) &  !(X %in% c(0.25,0.75)))
  

## Only 187 (! 13) are right on, 13 are not right at the slot
plants2024 %>%
  filter(transectID %% 2 == 0 & 
           x %in% c(0.25, 0.75) & 
           y %in% c(0.25, 0.75, 1.25, 1.75, 2.25, 2.75, 3.25, 3.75, 4.25, 4.75))
```




Gimenez 2020 <https://www.youtube.com/watch?v=VR8qdNvCaGk>     
phi(.), p(.)   
```{r}

# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi * z[i,t-1]) # will be alive on first encounter, then Bernoulli
    
    # Obervation process
    y[i,t] ~ dbern(p * z[i,t]) # true state times prob of detection
    
    } # t time
  
} # loop over all i individuals

phi ~ dunif(0,1) # prior for survival
p ~ dunif(0,1) # Prior for recapture




```

CJS phi(t), p(t)   
```{r}

# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi[t-1] * z[i,t-1]) # will be alive on first encounter, then Bernoulli, survival for each time interval
    
    # Obervation process
    y[i,t] ~ dbern(p[t-1] * z[i,t]) # true state times prob of detection, detection for each time interval
    
    } # t time
  
} # loop over all i individuals

## Need prior for each occasion
for(t in 1:n.occasions-1){
  phi[t] ~ dunif(0,1) # prior for survival
  p[t] ~ dunif(0,1) # Prior for recapture
}




```


Differences among groups, individual covariates     
```{r}


# Likelihood
for(i in 1:nind){
  
  # Define latent state at first capture
  z[i,f[i]] <- 1  # vector of when first encounter happened, always alive when first detected
  
  for(t in (f[i]+1):n.occasions){  # loop over time from the second encounter onward
    # State process
    z[i,t] ~ dbern(phi[i,t-1] * z[i,t-1]) # will be alive on first encounter, then Bernoulli, survival for each time interval
    
    # Obervation process
    y[i,t] ~ dbern(p[i,t-1] * z[i,t]) # true state times prob of detection, detection for each time interval
    
    } # t time
  
} # loop over all i individuals

## Need prior for each occasion
for(i in 1:nind){
  for(t in 1:(n.occasions-1)){  # in interval from t to t+1
    phi[i,t] ~ dunif(0,1) # prior for survival
    p[i,t] ~ dunif(0,1) # Prior for recapture
  }
}

```

Apply constraints on parameters, phi(.), p(.)   
```{r}

# Priors and constraints 
for(i in 1:nind){
  for(t in 1:(n.occasions-1)){
    phi[i,t] <- mean.phi   # not a 'mean' but a constant
    p[i,t] <- mean.p       # not a 'mean' but a constant
  }
}  

# Prior  
mean.phi ~ dunif(0,1)
mean.p ~ dunif(0,1)


```



Simulate capture-history matrix   
```{r}
n.occasions <- 6
marked <- rep(50, n.occasions-1)   # Annual number of newly marked individuals
phi <- rep(0.65, n.occasions-1)
p <- rep(0.4, n.occasions-1)

# Define matrices with survival and recapture probs
PHI <- matrix(phi, ncol = n.occasions-1, nrow = sum(marked))
P <- matrix(p, ncol = n.occasions-1, nrow=sum(marked))

simul.cjs <- function(PHI, P, marked){
  n.occasions <- dim(PHI)[2] + 1
  CH <- matrix(0, ncol = n.occasions, nrow = sum(marked))
  
  # Define a vector with the occasion of marking
  mark.occ <- rep(1:length(marked), marked[1:length(marked)])
  # Fill the CH matrix 
  for(i in 1:sum(marked)){
    CH[i, mark.occ[i]] <- 1     # First is a 1
    if(mark.occ[i] == n.occasions) next
      for(t in (mark.occ[i]+1):n.occasions){
        # Bernoulli trial for survival
        sur <- rbinom(1,1,PHI[i,t-1])
        if(sur==0) break   # If dead, move to next individual
        # Bernoulli for recapture
        rp <- rbinom(1,1,P[i,t-1])
        if(rp==1) CH[i,t] <- 1  # If you recaptured, it gets a '1'
      } # t
  } # i
return(CH)
  }

## Simulate!
sim1 <- simul.cjs(PHI, P, marked)

# Create vector with occasion of marking  
get.first <- function(x) min(which(x != 0))
f <- apply(sim1, 1, get.first)  ## Apply across rows


## BUGS  
SimulCJS <- 
  paste("
model {
  
  # Constraints
  for(i in 1:nind){
    for(t in 1:(n.occasions-1)){
      phi[i,t] <- mean.phi
      p[i,t] <- mean.p
    }
  }
  
  # Priors
  mean.phi ~ dunif(0,1)
  mean.p ~ dunif(0,1)
  
  # Likelihood
  for(i in 1:nind){
  
    # Define latent state at first capture
    z[i,f[i]] <- 1
    for(t in (f[i]+1):n.occasions){
    
      # State process
      z[i,t] ~ dbern(phi[i,t-1] * z[i, t-1])
      
      # Observation process
      y[i,t] ~ dbern(p[i,t-1] * z[i,t])
    }
  }
}

")

writeLines(SimulCJS, "SimulCJS.jags")

jags.data <- list(y = sim1,
                  f= f,
                  nind = nrow(sim1),
                  n.occasions = ncol(sim1))

# Set 'good' initial values
z.inits <- function(ch){
  state <- ch
  state[state==0] <- 1
  get.first <- function(x){ min(which(x != 0)) }
  f <- apply(ch, 1, get.first)
    for(i in 1:nrow(ch)){
      state[i, 1:f[i]] <- NA
    }
  return(state)
}

inits <- function(){list(mean.phi = runif(1,0,1),
                         mean.p = runif(1,0,1),
                         z = z.inits(sim1))}   # The latent states (alive, dead) also need initial values
  # Could monitor the latent states (if we have missing data)

parameters <- c("mean.phi","mean.p")

# MCMC settings
ni <- 1000
nt <- 1
nb <- 500
nc <- 3

cjs.c.c <- jags(data = jags.data,
                inits = inits,
                parameters.to.save = parameters,
                model.file = "SimulCJS.jags",
                n.chains = nc,
                n.thin = nt,
                n.iter = ni, n.burnin = nb,
                working.directory = getwd())

print(cjs.c.c, digits = 3)

## This is around 50 minutes

# save(cjs.c.c, file = )
```

Second part <https://www.youtube.com/watch?v=vYWj50Sj-q4>  
Random time effects
```{r}

n.occasions >- 12
marked <- rep(50, n.occasions-1)  ## Annual number of newly marked individuals
mean.phi <- 0.65
sigma2.phi <- 1
p <- rep(0.4, n.occasions-1)

## Annual survival probabilities on logistic scale
logit.phi <- rnorm(n.occasions-1, qlogis(mean.phi), sigma2.phi^0.5)
logit.phi
phi <- plogis(logit.phi)
phi
```


https://www.youtube.com/watch?v=vYWj50Sj-q4 
stopped at Minute 29
